calculate_transition_probabilities <- function(x, lx = 1L) {
    .Call('_RTransferEntropy_calculate_transition_probabilities', PACKAGE = 'RTransferEntropy', x, lx)
}

cluster_gen <- function(x, lx = 1L, y = NULL, ly = NULL, prog = TRUE) {
    .Call('_RTransferEntropy_cluster_gen', PACKAGE = 'RTransferEntropy', x, lx, y, ly, prog)
}

freq_table <- function(x) {
    .Call('_RTransferEntropy_freq_table', PACKAGE = 'RTransferEntropy', x)
}
.onAttach <- function(...) {
    set_quiet(FALSE)
}

# first to upper
fupper <- function(x) paste0(toupper(substr(x, 1, 1)), substr(x, 2, nchar(x)))

# returns an s if n > 1 (i.e., sprintf("we have n = %s sample%s", n, mult_s(n)))
mult_s <- function(n) ifelse(n > 1, "s", "")

# checks the dimensions of an input and takes the first column if possible
check_dimension <- function(x) {
    if (is.matrix(x) || is.data.frame(x)) {
        if (ncol(x) == 1) {
            x <- x[, 1]
        } else {
            stop("x and y must be a vector.")
        }
    }
    return(x)
}

# wrapper for calc_te and cal_ete that calculates the values
calc_te_ete <- function(restype = "te",
                        x, y, lx = 1, ly = 1, q = 0.1,
                        entropy = "Shannon",
                        shuffles = 100,
                        type = "quantiles",
                        quantiles = c(5, 95),
                        bins = NULL,
                        limits = NULL,
                        burn = 50,
                        seed = NULL,
                        na.rm = TRUE) {
    if (!is.null(seed)) set.seed(seed)
    
    restype <- tolower(restype)
    if (!restype %in% c("te", "ete")) {
        stop("Internal Error, restype has to be te or ete")
    }
    
    # Check for unequal length of time series
    if (length(x) != length(y)) {
        stop("x and y must be of same length.")
    }
    
    # Check that type is specified correctly
    if (!type %in% c("quantiles", "bins", "limits", "q", "b", "l")) {
        stop("type must be either 'quantiles', 'bins' or 'limits'.")
    }
    
    if (nchar(type) == 1) {
        if (type == "q") {
            type <- "quantiles"
        } else if (type == "b") {
            type <- "bins"
        } else {
            type <- "limits"
        }
    }
    
    # Check/Restrict number of classes and Markov order/lags
    if (length(quantiles) > 20 || length(bins) > 20 || length(limits) > 20) {
        stop(paste(
            "Number of classes should not exceed 20. Do not expect sensical results",
            "when using too many classes and/or lags."
        ))
    }
    
    if (lx > 20 || ly > 20) {
        stop(paste(
            "Markov order/number of lags should not exceed 20.",
            "Do not expect sensical results when using too many classes and/or lags."
        ))
    }
    
    if (lx != ly) {
        warning(paste(
            "Markov order/number of lags should be identical for both time series to",
            "facilitate interpretation of results. Consider setting lx = ly."
        ))
    }
    
    # check input of data
    
    # Check for unequal length of time series
    if (length(x) != length(y)) stop("x and y must be of same length.")
    x <- check_dimension(x)
    y <- check_dimension(y)
    
    # Remove missing values
    mis_values <- is.na(x) | is.na(y)
    if (na.rm == TRUE) {
        x <- x[!mis_values]
        y <- y[!mis_values]
    } else {
        if (any(mis_values)) return(NA)
    }
    
    # Check that transfer entropy measure is specified correctly
    entropy <- tolower(entropy)
    # Allow for specifying the first character only
    if (nchar(entropy) == 1 && entropy %in% c("s", "r")) {
        entropy <- if (entropy == "s") "shannon" else "renyi"
    }
    
    if (!entropy %in% c("shannon", "renyi")) {
        stop("entropy must be either 'Shannon' or 'Renyi'.")
    }
    
    # Check that q is between 0 and 1
    if (entropy == "renyi") {
        if (q < 0) {
            stop("q must follow 0 < q < 1")
        } else if (q >= 1) {
            warning(paste(
                "As q-->1, Renyi transfer entropy converges to Shannon transfer",
                "entropy. Shannon transfer entropy is calculated."
            ))
            entropy <- "shannon"
        }
    }
    
    # Check quantiles
    if (type == "quantiles" && (min(quantiles) < 0 || max(quantiles) > 100)) {
        stop("Quantiles must be between 0 and 100")
    }
    
    if (type == "quantiles" && max(quantiles) <= 1) {
        warning(paste(
            "Expected quantiles between 0 and 100 but found between 0 and 1,",
            "multiplying by 100."
        ))
        quantiles <- quantiles * 100
    }
    
    # Remove missing values
    mis_values <- is.na(x) | is.na(y)
    x <- x[!mis_values]
    y <- y[!mis_values]
    
    if (length(x) == 0) stop("x and y must have non-missing values.")
    
    x <- code_sample(x, type, quantiles, bins, limits)
    y <- code_sample(y, type, quantiles, bins, limits)
    
    # only calculate the X->Y direction
    if (entropy == "shannon") {
        te <- calc_te_shannon(y, lx = ly, x, ly = lx)
        if (restype == "ete") {
            consty <- shuffle_shannon(
                x = y,
                lx = ly,
                y = x,
                ly = lx,
                shuffles = shuffles
            )
            ete <- te - consty
            ete <- max(0, ete)
        }
        te <- max(0, te)
    } else {
        # RENYI
        te <- calc_te_renyi(y, lx = ly, x, ly = lx, q = q)
        if (restype == "ete") {
            consty <- shuffle_renyi(
                x = y,
                lx = ly,
                y = x,
                ly = lx,
                shuffles = shuffles,
                q = q
            )
            ete <- te - consty
        }
    }
    
    if (restype == "ete") {
        return(ete)
    } else {
        return(te)
    }
}

markov_boot_step <- function(x, lx, burn = 50) {
    n <- length(x) + burn
    bootvec <- numeric(n)
    
    # First draw
    pr <- freq_table(x)
    bootvec[1] <- sample(names(pr), 1, prob = pr)
    
    # Draws
    for (i in 2:(lx + 1)) {
        tprob <- calculate_transition_probabilities(x, lx = i - 1)
        val <- tprob[[bootvec[i - 1]]]
        
        draw <- ifelse(length(names(val)) == 1,
                       names(val),
                       sample(names(val), 1, prob = val)
        )
        
        bootvec[i] <- strsplit(draw, " ")[[1]][i]
    }
    
    tprob <- calculate_transition_probabilities(x, lx)
    
    for (i in (lx + 2):n) {
        val <- tprob[[bootvec[i - 1]]]
        
        draw <- ifelse(length(names(val)) == 1,
                       names(val),
                       sample(names(val), 1, prob = val)
        )
        
        bootvec[i] <- strsplit(draw, " ")[[1]][lx + 1]
    }
    
    bootvec <- bootvec[(burn + 1):n]
    
    return(as.numeric(bootvec))
}
calc_te_shannon <- function(x, lx, y, ly) {
    
    # Frequencies
    #------------------------------
    # x(k+1) and y(j)
    k1_j <- cluster_gen(x, lx = lx, y, ly = ly)
    nck1_j <- length(k1_j)
    
    # x(k+1)
    k1 <- cluster_gen(x, lx = lx)
    
    # x(k) and y(j)
    k_j <- cluster_gen(x, lx = lx, y, ly = ly, prog = FALSE)
    
    # x(k)
    k <- cluster_gen(x, lx = lx, prog = FALSE)
    
    # Transfer entropy
    #------------------------------
    entropy <- numeric(nck1_j)
    for (i in 1:nck1_j) {
        names_ <- strsplit(names(k1_j[i]), " ")[[1]]
        
        p1 <- k1[paste0(names_[1:(lx + 1)], collapse = " ")]
        p2 <- k_j[paste0(names_[-(lx + 1)], collapse = " ")]
        p3 <- k[paste0(names_[1:lx], collapse = " ")]
        entropy[i] <- k1_j[i] * log2((k1_j[i] * p3) / (p2 * p1))
    }
    
    shan_entropy <- sum(entropy)
    
    return(shan_entropy)
}
code_sample <- function(x,
                        type = "quantiles",
                        quantiles = c(5, 95),
                        bins = NULL,
                        limits = NULL,
                        scale = 1e10) {
    if (type %in% c("bins", "limits")) {
        UB <- max(x)
        LB <- min(x)
        
        # find the respective OSeq for the time series
        if (type == "bins") {
            if (is.null(bins)) stop("Warning: Bins not defined\nExecution halted\n")
            
            OSeq <- LB + ((UB - LB) / bins) * (0:(bins))
        } else {
            if (is.null(limits)) stop("Warning: Bins not defined\nExecution halted\n")
            
            limits <- sort(limits)
            OSeq <- c(LB, limits, UB)
        }
        
        OSeq[length(OSeq)] <- UB + 1
        
        for (j in 1:(length(OSeq) - 1)) {
            x[x >= OSeq[j] & x < OSeq[j + 1]] <- j * scale
        }
    } else if (type == "quantiles") {
        Qtl <- quantile(x, type = 8, probs = quantiles / 100)
        Qtl <- c(Qtl, max(x))
        Qlength <- length(Qtl)
        
        for (j in 1:Qlength) {
            x[x <= Qtl[j]] <- j * scale
        }
    }
    x <- x / scale
    
    return(x)
}
